"""
SQL Fixer Utility
自动修复AI模型生成的SQL查询中的常见问题
"""

import re
import logging
from typing import Tuple, List, Dict

logger = logging.getLogger(__name__)

class SQLFixer:
    """
    Automatically fix common SQL issues generated by AI models
    自动修复AI模型生成的常见SQL问题
    """
    
    def __init__(self):
        self.common_fixes = [
            self._fix_cte_alias_mismatch,
            self._fix_chinese_aliases,
            self._fix_missing_table_aliases,
            self._fix_invalid_joins,
            self._fix_group_by_issues,
            self._fix_format_function_compatibility,
            self._fix_doris_function_compatibility,
        ]
    
    def fix_sql(self, sql: str) -> Tuple[str, List[str]]:
        """
        Apply all available fixes to the SQL
        对SQL应用所有可用的修复
        
        Returns:
            Tuple[str, List[str]]: (fixed_sql, list_of_fixes_applied)
        """
        if not sql or not sql.strip():
            return sql, []
        
        fixed_sql = sql.strip()
        fixes_applied = []
        
        for fix_func in self.common_fixes:
            try:
                new_sql, fix_description = fix_func(fixed_sql)
                if new_sql != fixed_sql:
                    fixes_applied.append(fix_description)
                    fixed_sql = new_sql
                    logger.info(f"Applied fix: {fix_description}")
            except Exception as e:
                logger.warning(f"Fix function {fix_func.__name__} failed: {e}")
        
        return fixed_sql, fixes_applied
    
    def _fix_cte_alias_mismatch(self, sql: str) -> Tuple[str, str]:
        """
        Fix CTE alias mismatches - the most common issue we've seen
        修复CTE别名不匹配问题 - 我们看到的最常见问题
        """
        # Pattern: WITH cte AS (SELECT field AS '中文别名' ...) SELECT m.field FROM cte m
        # This should be: SELECT m.中文别名 FROM cte m
        
        cte_pattern = r'WITH\s+(\w+)\s+AS\s*\(\s*SELECT\s+(.*?)\s+FROM\s+(.*?)\s*\)\s*SELECT\s+(.*?)\s+FROM\s+\1\s+(\w+)'
        
        match = re.search(cte_pattern, sql, re.IGNORECASE | re.DOTALL)
        if not match:
            return sql, ""
        
        cte_name, cte_select, cte_from, main_select, main_alias = match.groups()
        
        # Extract field mappings from CTE
        field_mappings = {}
        cte_fields = re.findall(r'(\w+)\s+AS\s+[\'"]([^\'"]+)[\'"]', cte_select)
        
        if not cte_fields:
            return sql, ""
        
        # Build mapping of original field -> alias
        for original_field, alias in cte_fields:
            field_mappings[original_field] = alias
        
        # Fix main SELECT clause
        fixed_main_select = main_select
        for original_field, alias in field_mappings.items():
            # Replace m.original_field with m.alias (quoted if contains Chinese)
            pattern = rf'{main_alias}\.{original_field}\b'
            if re.search(r'[\u4e00-\u9fff]', alias):  # Contains Chinese
                replacement = f'{main_alias}.`{alias}`'
            else:
                replacement = f'{main_alias}.{alias}'
            fixed_main_select = re.sub(pattern, replacement, fixed_main_select)
        
        # Reconstruct the SQL
        fixed_sql = f"WITH {cte_name} AS (SELECT {cte_select} FROM {cte_from}) SELECT {fixed_main_select} FROM {cte_name} {main_alias}"
        
        # Add the rest of the original SQL (WHERE, GROUP BY, etc.)
        remaining_sql = sql[match.end():]
        if remaining_sql.strip():
            fixed_sql += " " + remaining_sql.strip()
        
        if fixed_sql != sql:
            return fixed_sql, "修复了CTE中的字段别名引用问题"
        
        return sql, ""
    
    def _fix_chinese_aliases(self, sql: str) -> Tuple[str, str]:
        """
        Fix issues with Chinese aliases in SQL
        修复SQL中中文别名的问题
        """
        fixes_applied = []
        fixed_sql = sql
        
        # Fix 1: Remove incorrect double backticks and trailing comma-backtick
        # Pattern: ``中文别名`,` -> `中文别名`
        incorrect_pattern = r'``([^`]*[\u4e00-\u9fff][^`]*)\`,\`'
        if re.search(incorrect_pattern, fixed_sql):
            fixed_sql = re.sub(incorrect_pattern, r'`\1`', fixed_sql)
            fixes_applied.append("修复了错误的双反引号格式")
        
        # Fix 2: Find Chinese aliases that aren't properly quoted
        # Pattern: AS 中文别名 (without quotes) -> AS `中文别名`
        chinese_alias_pattern = r'AS\s+([^`\s,]+[\u4e00-\u9fff][^`\s,]*)\s*(?=[,\s]|$)'
        
        def quote_chinese_alias(match):
            alias = match.group(1)
            return f'AS `{alias}`'
        
        temp_sql = re.sub(chinese_alias_pattern, quote_chinese_alias, fixed_sql)
        if temp_sql != fixed_sql:
            fixes_applied.append("为中文字段别名添加了反引号")
            fixed_sql = temp_sql
        
        # Fix 3: Handle already quoted aliases that might have extra quotes
        # Pattern: AS `中文别名`, -> AS `中文别名`,
        extra_quote_pattern = r'AS\s+`([^`]*[\u4e00-\u9fff][^`]*)`\s*,\s*`'
        if re.search(extra_quote_pattern, fixed_sql):
            fixed_sql = re.sub(extra_quote_pattern, r'AS `\1`,', fixed_sql)
            fixes_applied.append("清理了多余的引号")
        
        if fixes_applied:
            return fixed_sql, "; ".join(fixes_applied)
        
        return sql, ""
    
    def _fix_missing_table_aliases(self, sql: str) -> Tuple[str, str]:
        """
        Fix missing table aliases in complex queries
        修复复杂查询中缺失的表别名
        """
        # This is a complex fix, for now just return as-is
        # TODO: Implement proper table alias detection and fixing
        return sql, ""
    
    def _fix_invalid_joins(self, sql: str) -> Tuple[str, str]:
        """
        Fix invalid JOIN conditions
        修复无效的JOIN条件
        """
        # Look for JOINs that might be problematic
        # For example: LEFT JOIN table ON field1 = field2 (without table prefixes)
        
        # This is a placeholder for more sophisticated JOIN fixing
        return sql, ""
    
    def _fix_group_by_issues(self, sql: str) -> Tuple[str, str]:
        """
        Fix GROUP BY clause issues including ONLY_FULL_GROUP_BY compatibility
        修复GROUP BY子句问题，包括ONLY_FULL_GROUP_BY兼容性
        """
        fixes_applied = []
        fixed_sql = sql
        
        # Fix 1: Chinese aliases in GROUP BY
        group_by_pattern = r'GROUP\s+BY\s+([^\s]+\.)?([^\s,]+[\u4e00-\u9fff][^\s,]*)'
        
        def fix_group_by_field(match):
            table_prefix = match.group(1) or ""
            field_name = match.group(2)
            return f'GROUP BY {table_prefix}`{field_name}`'
        
        temp_sql = re.sub(group_by_pattern, fix_group_by_field, fixed_sql, flags=re.IGNORECASE)
        if temp_sql != fixed_sql:
            fixes_applied.append("修复了GROUP BY中的中文字段引用")
            fixed_sql = temp_sql
        
        # Fix 2: ONLY_FULL_GROUP_BY compatibility
        # Detect SELECT fields that are not in GROUP BY and not aggregated
        group_by_match = re.search(r'GROUP\s+BY\s+([^ORDER\s]+)', fixed_sql, re.IGNORECASE)
        if group_by_match:
            group_by_fields = [field.strip() for field in group_by_match.group(1).split(',')]
            
            # Extract SELECT fields (simplified pattern)
            select_match = re.search(r'SELECT\s+(.*?)\s+FROM', fixed_sql, re.IGNORECASE | re.DOTALL)
            if select_match:
                select_clause = select_match.group(1)
                
                # Check for common problematic patterns
                # Pattern 1: SELECT field1, field2 FROM table GROUP BY field1
                # Should be: SELECT field1, AVG(field2) FROM table GROUP BY field1
                
                # Look for non-aggregated fields in SELECT that aren't in GROUP BY
                # This is a simplified fix for the most common case
                if 'overdue_rate' in select_clause and 'stat_month' in str(group_by_fields):
                    # Common pattern: SELECT stat_month, overdue_rate ... GROUP BY stat_month
                    # Fix: SELECT stat_month, AVG(overdue_rate) ... GROUP BY stat_month
                    pattern = r'(\w+),\s*overdue_rate'
                    replacement = r'\1, AVG(overdue_rate) as avg_overdue_rate'
                    temp_sql = re.sub(pattern, replacement, fixed_sql)
                    if temp_sql != fixed_sql:
                        fixes_applied.append("为非聚合字段添加了AVG函数以兼容ONLY_FULL_GROUP_BY")
                        fixed_sql = temp_sql
                
                # Pattern 2: DATE_FORMAT with non-aggregated field
                date_format_pattern = r'(DATE_FORMAT\([^)]+\)\s+AS\s+\w+),\s*(\w+)(\s+FROM.*?GROUP\s+BY\s+[^,\s]+)'
                if re.search(date_format_pattern, fixed_sql, re.IGNORECASE | re.DOTALL):
                    def fix_date_format_group_by(match):
                        date_part = match.group(1)
                        field = match.group(2)
                        rest = match.group(3)
                        # Add aggregation to the non-grouped field
                        return f"{date_part}, AVG({field}) as avg_{field}{rest}"
                    
                    temp_sql = re.sub(date_format_pattern, fix_date_format_group_by, fixed_sql, flags=re.IGNORECASE | re.DOTALL)
                    if temp_sql != fixed_sql:
                        fixes_applied.append("为DATE_FORMAT查询添加了聚合函数以兼容ONLY_FULL_GROUP_BY")
                        fixed_sql = temp_sql
        
        if fixes_applied:
            return fixed_sql, "; ".join(fixes_applied)
        
        return sql, ""

    def _fix_format_function_compatibility(self, sql: str) -> Tuple[str, str]:
        """
        Fix FORMAT function compatibility issues
        修复FORMAT函数兼容性问题
        """
        fixes_applied = []
        fixed_sql = sql
        
        # Pattern 1: FORMAT(numeric_value, 2) -> ROUND(numeric_value, 2)
        format_numeric_pattern = r'FORMAT\(([^,)]+),\s*(\d+)\)'
        
        def fix_numeric_format(match):
            value = match.group(1)
            decimals = match.group(2)
            return f'ROUND({value}, {decimals})'
        
        temp_sql = re.sub(format_numeric_pattern, fix_numeric_format, fixed_sql)
        if temp_sql != fixed_sql:
            fixes_applied.append("将FORMAT函数替换为ROUND函数")
            fixed_sql = temp_sql
        
        # Pattern 2: CONCAT('¥', FORMAT(...)) -> CONCAT('¥', ROUND(...))
        # This should already be handled by the above pattern
        
        # Pattern 3: More complex FORMAT patterns that might need specific handling
        # Check for any remaining FORMAT functions that might need different treatment
        remaining_format = re.search(r'FORMAT\([^)]+\)', fixed_sql)
        if remaining_format:
            # For any remaining FORMAT functions, try to convert them
            format_pattern = r'FORMAT\(([^)]+)\)'
            def fix_remaining_format(match):
                content = match.group(1)
                # If it's a simple numeric format, default to 2 decimal places
                if ',' not in content:
                    return f'ROUND({content}, 2)'
                else:
                    # Split by comma and handle
                    parts = content.split(',')
                    if len(parts) == 2:
                        value = parts[0].strip()
                        decimals = parts[1].strip()
                        return f'ROUND({value}, {decimals})'
                # Fallback: just remove FORMAT and keep the content
                return content
            
            temp_sql = re.sub(format_pattern, fix_remaining_format, fixed_sql)
            if temp_sql != fixed_sql:
                fixes_applied.append("处理了剩余的FORMAT函数兼容性问题")
                fixed_sql = temp_sql
        
        if fixes_applied:
            return fixed_sql, "; ".join(fixes_applied)
        
        return sql, ""

    def _fix_doris_function_compatibility(self, sql: str) -> Tuple[str, str]:
        """
        Fix Doris database function compatibility issues
        修复Doris数据库函数兼容性问题
        """
        fixes_applied = []
        fixed_sql = sql
        
        # Fix 1: DATE_ROUND function - not supported in Doris
        # Pattern: DATE_ROUND(date_field, '%Y-%m-%d') -> date_field (if date_field is already date type)
        date_round_pattern = r'DATE_ROUND\(([^,)]+),\s*[\'"]%Y-%m-%d[\'"]?\)'
        
        def fix_date_round(match):
            field = match.group(1).strip()
            return field  # Remove DATE_ROUND wrapper since field is already date type
        
        temp_sql = re.sub(date_round_pattern, fix_date_round, fixed_sql)
        if temp_sql != fixed_sql:
            fixes_applied.append("移除了Doris不支持的DATE_ROUND函数")
            fixed_sql = temp_sql
        
        # Fix 2: Other potentially problematic functions for Doris
        # Add more Doris-specific function fixes here as needed
        
        if fixes_applied:
            return fixed_sql, "; ".join(fixes_applied)
        
        return sql, ""

def create_sql_fixer() -> SQLFixer:
    """
    Factory function to create SQL fixer instance
    创建SQL修复器实例的工厂函数
    """
    return SQLFixer() 